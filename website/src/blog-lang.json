[
  {
    "language": "css",
    "blogs": [
      {
        "title": "outline",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "To debug CSS we can set the outline of all elements to be a certain colour."
            ]
          },
          {
            "type": "Code",
            "language": "css",
            "code": [
              "* {",
              "    outline:1px solid red!important",
              "}"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "[Link](https://blog.openreplay.com/using-CSS-background-color-to-debug-web-pages/)"
            ]
          }
        ]
      }
    ]
  },
  {
    "language": "js",
    "blogs": [
      {
        "title": "sort lexicographic",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "The in-build `Array.sort` method sorts by lexicographic order so:"
            ]
          },
          {
            "type": "Code",
            "language": "js",
            "code": [
              "const x = [1, 2, 10, 20];",
              "x.sort();",
              "assert(x[0] === 1);",
              "assert(x[1] === 10);",
              "assert(x[2] === 2);",
              "assert(x[3] === 20);"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". A sorting function must be provided"
            ]
          },
          {
            "type": "Code",
            "language": "js",
            "code": [
              "const x = [1, 2, 10, 20];",
              "x.sort((a, b) => a - b);"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      }
    ]
  },
  {
    "language": "shell",
    "blogs": [
      {
        "title": "zsh colons",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Putting `:` and one of `ahl` changes the behaviour of a path expansion in `zsh`."
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "",
              "[ -d top ] && rm -rf top",
              "mkdir -p top/next",
              "seq 3 | xargs -I % touch top/next/%",
              "",
              "# l behaviour is to delete the first letter",
              "",
              "zsh -c 'for f in top/next/*; do echo \"$f:la\"; done' > zsh-out.txt",
              "",
              "cat << EOF > zsh-exp.txt",
              "top/next/1a",
              "top/next/2a",
              "top/next/3a",
              "EOF",
              "",
              "diff zsh-???.txt",
              "",
              "bash -c 'for f in top/next/*; do echo \"$f:la\"; done' > bash-out.txt",
              "",
              "cat << EOF > bash-exp.txt",
              "top/next/1:la",
              "top/next/2:la",
              "top/next/3:la",
              "EOF",
              "",
              "diff bash-???.txt"
            ]
          }
        ]
      },
      {
        "title": "git reset",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "The command `git reset` is the opposite of `git add`.  ",
              "It allows you to remove a file from the staging area in stage 2 here:"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "1. file changed in working directory",
              "2. add to staging area",
              "3. commit to .git"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      },
      {
        "title": "pushd popq",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Name recent folders with a stack-history rather than using `cd -`.  ",
              "Example:"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "$ pushd a",
              "# now in a",
              "a",
              "$ pushd b",
              "# now in b",
              "b a",
              "$ pushd c",
              "# now in c",
              "c b a",
              "$ popd",
              "# now in b",
              "a"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              ".  ",
              "[guide](https://www.youtube.com/watch?v=AVXYq8aL47Q&t=217)"
            ]
          }
        ]
      },
      {
        "title": "find exec",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Options"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "1. `find -exec command {} +` - work on aggregated file list",
              "2. `find -exec [ command ] \\;` - work on individual files"
            ]
          },
          {
            "type": "Header",
            "level": 2,
            "content": "Rough Shell Translation"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "1. `-exec command {} +`:"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "files='f1 f2 ... fn'",
              "command f1 f2 ... fn"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "2. `-exec [ command ] \\;` is like:"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "files='f1 f2 ... fn'",
              "command f1",
              "command f2",
              "...",
              "command fn"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "## Delimiter"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "`{}` is the currently iterated file\\[s\\]."
            ]
          },
          {
            "type": "Header",
            "level": 2,
            "content": "1 - `{} +`"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "1. `find` will aggregate all files (ie. say in a variable `fs`)",
              "2. The `{}` will be unpacked like so: `command f1 f2 f3 ...`"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "So these two should be the same"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "echo 1 > james",
              "echo 2 > jane",
              "echo 3 > john",
              "find . -name 'ja*' -exec cat {} +"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "```sh",
              "echo 1 > james",
              "echo 2 > jane",
              "echo 3 > john",
              "cat james jane",
              "```"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              ". They both will output"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "1",
              "2"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". So `command` needs to be able to take in multiple command line arguments."
            ]
          },
          {
            "type": "Header",
            "level": 2,
            "content": "2 - `[ command ] \\;`"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The `;` character is a delimeter to the `-exec` flag.",
              "We can't type raw `;` because the shell will interpret it first.",
              "Hence we need to escape it - `\\;`.",
              "Since we are working with individual files you can use `{}` to mean the current file name."
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "touch james jane john",
              "find . -name 'ja*' -exec echo \"{} says hello\" \\;"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "will output"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "james says hello",
              "jane says hello"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Sources"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "[baeldung](https://www.baeldung.com/linux/find-exec-command)"
            ]
          }
        ]
      },
      {
        "title": "glob var order",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "1. Variable substitution occurs",
              "2. Then globbing"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Proof"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "If there are files"
            ]
          },
          {
            "type": "Code",
            "language": "txt",
            "code": [
              "a aa b c"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "then the glob"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "a*"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "should have the files"
            ]
          },
          {
            "type": "Code",
            "language": "txt",
            "code": [
              "a aa"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". If you run"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "echo a*"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "you will get the right answer"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "a aa"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". But if you put the glob in a variable it won't work."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Script"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "```sh",
              "touch a aa b c",
              "echo a*",
              "l='a*'",
              "echo $l",
              "```"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Double Quotes"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Note that if you try"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "echo \"$l\""
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "the star will get interpretted literally."
            ]
          }
        ]
      },
      {
        "title": "git upstream",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "How to fix this problem:"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "fatal: The current branch main has no upstream branch.",
              "To push the current branch and set the remote as upstream, use",
              "",
              "    git push --set-upstream origin main",
              "",
              "To have this happen automatically for branches without a tracking",
              "upstream, see 'push.autoSetupRemote' in 'git help config'."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". Run this:"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "git config --global --add --bool push.autoSetupRemote true"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "from [here](https://stackoverflow.com/questions/29422101/automatically-track-remote-branch-with-git)."
            ]
          }
        ]
      },
      {
        "title": "terminal sizing",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Press `Command` and then `-` or `+` to make the fornt smaller or larger respectively.  ",
              "Afterwards run `reset` to fix formatting."
            ]
          }
        ]
      },
      {
        "title": "history",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Run `history` to see previously run shell commands.  ",
              "All commands have are enumerated so you can run `!101` eg. to run whichever command was enumerated as `101`."
            ]
          }
        ]
      },
      {
        "title": "zsh login",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "I am trying to decide if `~/.zshrc` is the best place to put updates to `$PATH`.",
              "Right now, putting modifications in `~/.zshrc` is resulting in duplicate folders."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Order of scripts"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "There are special scripts prefixed `z` in `/etc` and `~` which control the setup of the shell.",
              "The order is:"
            ]
          },
          {
            "type": "OrderedList",
            "list": [
              "`.zshenv`",
              "`.zprofile`",
              "`.zshrc`",
              "`.zlogin`",
              "`.zlogout`"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "There can be up to two copies of these files:"
            ]
          },
          {
            "type": "OrderedList",
            "list": [
              "The first run is in `/etc`. This is the default configuration",
              "The second one is in `~`. This overwrites the corresponding `/etc` version"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "Source [1](https://apple.stackexchange.com/questions/388622/zsh-zprofile-zshrc-zlogin-what-goes-where)."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Solution 1"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Source 1 recommends putting `$PATH` setup in `.zshenv`."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Solution 2"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Source [2](https://apple.stackexchange.com/questions/432226/homebrew-path-set-in-zshenv-is-overridden) recommends putting them in `zprofile`.",
              "The issue is that `/etc/zprofile` runs a script `path_helper`.",
              "This script will **append** changes to `$PATH` made from `~/.zshenv`.",
              "This is bad because we want our own changes to `$PATH` to be **prepended**."
            ]
          }
        ]
      },
      {
        "title": "duplicate path folders",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The folders in `$PATH` are getting duplicated.",
              "I am trying to find out why."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "Theories:"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| no. | desc                                      |",
              "| --- | ----------------------------------------- |",
              "| 1   | `.zshrc` is getting run twice             |",
              "| 2   | some other `zsh` file is running it twice |"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Hunch"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The issue is that folders like"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "/Users/sunny/OneDrive - UNSW/UNSW/Courses/Year 5 - 2023/seng3011"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "are getting recorded twice.",
              "These are only ever set in `~/.zshrc` so I know it is getting run twice."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Solution"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The following command can remove duplicate items from `$PATH`"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "typeset -U path"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Link [here](https://tech.serhatteker.com/post/2019-12/remove-duplicates-in-path-zsh/)"
            ]
          }
        ]
      },
      {
        "title": "installed utilities",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "These utilities were installed using `brew` on mac."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| Name  | Description                         |",
              "| ----- | ----------------------------------- |",
              "| `bat` | like `cat` with syntax highlighting |",
              "| `fzf` | fuzzy find a file name given a term |"
            ]
          }
        ]
      },
      {
        "title": "no multiline func",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "One line functions are syntax errors, so this is a syntax error"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "handle() { basename \"$1\" }"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      },
      {
        "title": "background fg",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Run `control-Z` to send a running program (like `vim file`) and then run `fg` to get it back.  "
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "vim hello.txt",
              "[ control-z ]",
              "# now brought back to terminal",
              "echo hi",
              "fg"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "[guide](https://www.youtube.com/watch?v=AVXYq8aL47Q&t=345s)"
            ]
          }
        ]
      },
      {
        "title": "no export function posix",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "POSIX compliance is sometimes difficult to work with in `dash`.  ",
              "Using `xargs` it is handy to use Shell functions with the `-exec` flag.",
              "This is better than having to write an individual file for shell functions.",
              "However as described in this [so post](https://stackoverflow.com/questions/1885871/exporting-a-function-in-shell)"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "In sh, it is not possible to export a function"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". The full explanation is in this [other post](https://stackoverflow.com/questions/29239806/how-to-export-a-function-in-bourne-shell)"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "No. The POSIX specification for export lacks the -f present in bash that allows one to export a function.",
              "A (very verbose) workaround is to save your function to a file and source it in the child script."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      },
      {
        "title": "do not store exit status",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Do not store the exit status `$?` in a variable.  ",
              "You will get this error:"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "read-only variable: status"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". The alternative would be to use a `trap` command.",
              "According to this [so post](https://stackoverflow.com/questions/36921658/save-command-output-on-variable-and-check-exit-status):"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "I recommend against the use of $? as much as possible, as it is fragile and easy to overlook when refactoring"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      },
      {
        "title": "bang bang",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "`!!` refers to the last run command."
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "echo hello",
              "sudo !! # this is the same as",
              "sudo echo hello"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "[guide](https://youtu.be/AVXYq8aL47Q?si=pSpSXghvq-Vq5P7p&t=524)"
            ]
          }
        ]
      },
      {
        "title": "bang end string",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "You cannot end a string with a bang like"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "echo \"fish!\"",
              ">"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". The prompt (PS2) will be shown"
            ]
          }
        ]
      },
      {
        "title": "newline at end",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Should I put a newline at the end of a file?"
            ]
          },
          {
            "type": "Header",
            "level": 2,
            "content": "Yes"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "It makes it easier to view the last line in an editor: the cursor will be not at the end."
            ]
          },
          {
            "type": "Header",
            "level": 2,
            "content": "No"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "When running `cat` on the file, an extra newline will get printed out."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Conclusion"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Yes a newline should be put in.",
              "`cat` is for command-line viewing of files only.",
              "I would prioritise the experience when I'm editing files."
            ]
          }
        ]
      },
      {
        "title": "folder change function",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Changing a folder in a function will persist outside it.  "
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "#!/bin/dash",
              "",
              "mkdir a",
              "cd a",
              "mkdir b",
              "",
              "change() {",
              "    cd b",
              "}",
              "",
              "change",
              "# and not a",
              "[ \"$(basename $(pwd))\" = b ]",
              "exit $?"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              ""
            ]
          }
        ]
      },
      {
        "title": "handy utilities",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "A list of handy Shell utilities."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| Utility    | Overview                                           | Mac (y/n) |",
              "| ---------- | -------------------------------------------------- | --------- |",
              "| `rename`   | easily rename files based on a pattern             | n         |",
              "| `paste`    | join matching line numbers in files by a delimiter | y         |",
              "| `realpath` | get the absoulte path for a given file             | y         |",
              "| `fc`       | edit the last shell command in editor              | y         |"
            ]
          }
        ]
      },
      {
        "title": "global path",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Changes to the `$PATH` environment variable made in `~/.zshrc` are not spread to other programs."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Context"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "There is a separate issue relating to the `latexindent` command not working.",
              "This GitHub [issue](https://github.com/James-Yu/LaTeX-Workshop/issues/2135) references a problem where the wrong `latexindent` command is getting run.",
              "The solution fixes this by changing the order of folders in `$PATH`."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Solution"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "This shell command can spread `$PATH` to other programs:"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "launchctl setenv PATH $PATH"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              ". Source [here](https://stackoverflow.com/questions/135688/setting-environment-variables-on-os-x).",
              "This can be added to `~/.zshrc`."
            ]
          }
        ]
      },
      {
        "title": "ifs bash",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "In `bash`, how the shell processes arguments expanded via"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "command $var"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "where `$var` is unquoted depends on the `IFS` variable.",
              "More information [here](https://unix.stackexchange.com/questions/26661/what-is-word-splitting-why-is-it-important-in-shell-programming/26672#26672).",
              "Normally, this"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "bash",
              "A='a b c'",
              "python3 -c 'import sys; print(\",\".join(sys.argv))' $A"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "will run `command` with three arguments `a b c`.",
              "This is because there is normally whitespace in `IFS`."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "Here is an example of something that will only run correctly on `zsh` compared to `bash`"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "#!/bin/zsh",
              "",
              "string=foo:bar:foobar",
              "old_ifs=\"$IFS\"",
              "IFS=\":\"",
              "for i in $string",
              "do",
              "  echo \"'$i' is the splitted word\"",
              "done"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "In `zsh`"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "'foo:bar:foobar' is the splitted word"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "compared to `bash`"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "'foo' is the splitted word",
              "'bar' is the splitted word",
              "'foobar' is the splitted word"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      },
      {
        "title": "null glob",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "The ability for an empty glob to return no results can be turned on."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Using `setopt`"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The shell command is"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "setopt -s nullglob"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "The `(N)` character"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The `(N)` character can be used to mimic this behaviour.",
              "Eg. if there are these files:"
            ]
          },
          {
            "type": "Code",
            "language": "txt",
            "code": [
              "a",
              "b",
              "c"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "then `echo fish*(N)` produces `` as per [here](https://unix.stackexchange.com/questions/26805/how-to-silently-get-an-empty-string-from-a-glob-pattern-with-no-matches)."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Not using glob at all"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Manually break the loop if the literal glob gets returned"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "for txt in *.txt",
              "do",
              "  [ -e \"$txt\" ] || break",
              "  echo \"loading data from $txt\"",
              "done"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "from [here](https://superuser.com/questions/519374/how-to-handle-bash-matching-when-there-are-no-matches)."
            ]
          }
        ]
      },
      {
        "title": "tmux",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Notes"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "1. Enter `tmux` to start",
              "2. Cannot enter `Command + k` to clear screen",
              "3. Any command letter that is a shift-pressed key, must have shift pressed to work"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Modifier"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Press the modifier key and then a command letter.",
              "In Zac's `.tmux.conf` this was `Control + a`."
            ]
          },
          {
            "type": "UnorderedList",
            "list": [
              "It is apparently the most ergonomic combination."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "By default it is `Control + b`.  ",
              "You have to release the modifier and then press the command letter as per this [guide](https://superuser.com/questions/266725/tmux-ctrlb-not-working).",
              "This is a list of [default command letters](https://man.openbsd.org/tmux#DEFAULT_KEY_BINDINGS)."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Windows"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "They are more like tabs in a browser."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| Letter | Description           |",
              "| ------ | --------------------- |",
              "| c      | make new window       |",
              "| &      | kill current window   |",
              "| 1..9   | go to window 1..9     |",
              "| ,      | rename window         |",
              "| p      | go to previous window |",
              "| n      | go to next window     |",
              "| &      | close window          |"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Pane"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "A window can be split into panes.",
              "Panes are closed by `Control + d` or the command letter `x`.",
              "Can switch using arrow keys as the command letter or `o`."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| Letter | Description              |",
              "| ------ | ------------------------ |",
              "| %      | split vertically         |",
              "| \"      | split horizontally       |",
              "| z      | toggle pane as full size |",
              "| x      | close pane               |"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Session"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "All open windows are saved in a session.",
              "Exiting is also referred to as **detatching**."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| Letter | Description         |",
              "| ------ | ------------------- |",
              "| d      | exit out of session |"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "Sessions are 0-indexed."
            ]
          },
          {
            "type": "Header",
            "level": 2,
            "content": "Shell Commands"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Run these via `tmux` then provide the argument."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "| Argument                | Description                                                            |",
              "| ----------------------- | ---------------------------------------------------------------------- |",
              "| `attach -t[n]`          | go back into a previous session replacing `[n]` with the index or name |",
              "| `rename-session [name]` | rename the session to `[name]`                                         |",
              "| `ls`                    | see all running sessions                                               |"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "Running `tmux` will start tmux with a new session."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Configuration"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "The configuration file is stored in `~/.tmux.conf`.",
              "When it is changed, `tmux` will automatically update in response.",
              "However, if there are any running sessions, they must all be [exited first](https://unix.stackexchange.com/questions/66606/tmux-not-sourcing-my-tmux-conf#answer-66607)."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "YouTube Guides"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "| Title                                                                              |",
              "| ---------------------------------------------------------------------------------- |",
              "| [Inside my iPad Pro SSH Setup - TMUX](https://www.youtube.com/watch?v=B-1wGwvUwm8) |"
            ]
          }
        ]
      },
      {
        "title": "nested double quoting",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "Do you need to wrap variables expanded in subshells with double quotes?  ",
              "No you don't, as soon as you write one `\"\"`, white spaces are preserved in variable expansions.",
              "If you did then this should print out `0`:"
            ]
          },
          {
            "type": "Code",
            "language": "sh",
            "code": [
              "[ -d t ] && rm -r t",
              "cd t",
              "touch 'three   two  one end.txt'",
              "full='t/three   two  one end.txt'",
              "cd ..",
              "[ \"$(basename $full)\" = \"$(basename \"$full\")\" ]",
              "echo $?"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      },
      {
        "title": "heredoc cat",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Background"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "I read that `cat` is not strictly needed in `heredocs`."
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "Heredocs are a shell-syntax feature so they don't require cat specifically."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "[Source](https://superuser.com/questions/1829271/how-do-i-pipe-a-heredoc)"
            ]
          }
        ]
      }
    ]
  },
  {
    "language": "rust",
    "blogs": [
      {
        "title": "ref keyword",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "The `ref` keyword allows you unpack a pattern match item as a reference.  ",
              "Normally, pattern matched items are moved."
            ]
          },
          {
            "type": "Code",
            "language": "rs",
            "code": [
              "let opt: Option<Vec<i32>> = Some(Vec<i32>::new());",
              "match opt {",
              "    // so here, vec is a reference",
              "    Some(ref vec) => {},",
              "    None => {}",
              "}"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "It would seem more natural to do something like"
            ]
          },
          {
            "type": "Code",
            "language": "rs",
            "code": [
              "Some(&vec)"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "but in Rust, only the right-hand side of an expression should have an `&`"
            ]
          },
          {
            "type": "Code",
            "language": "rs",
            "code": [
              "let x = 10;",
              "let y = &x; // we don't write let &y"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          }
        ]
      }
    ]
  },
  {
    "language": "html",
    "blogs": [
      {
        "title": "text fragment",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Text fragments offer a way to direct to a specific spot in an HTML file.",
              "The documentation from MDM is [here](https://developer.mozilla.org/en-US/docs/Web/URI/Fragment/Text_fragments#browser_compatibility).",
              "Anchor `<a>` tags in their `href` can redirect to an element's id using a hash like so:"
            ]
          },
          {
            "type": "Code",
            "language": "html",
            "code": [
              "<a href=\"#os.environ\">hello</a>"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "taken from [pydocs](https://docs.python.org/3/library/os.html#os.environ).",
              "The fragment is captured in the url like so:"
            ]
          },
          {
            "type": "Code",
            "language": "",
            "code": [
              "https://docs.python.org/3/library/os.html#os.environ"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "."
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Known Issues"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "[Some browsers](https://meta.stackoverflow.com/questions/425878/link-to-a-specific-spot-in-a-stack-overflow-question-answer) support the ability to create fragments based on a selection of text.",
              "However Firefox does not support this and it is prone to breaking."
            ]
          }
        ]
      }
    ]
  },
  {
    "language": "cpp",
    "blogs": [
      {
        "title": "self copy member initialiser list",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "The Problem"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "For the copy-assignment operator, the `this` object has already been constructed.",
              "So you do have to check for self copying.",
              "However, this operator is not a **constructor** so you don't have to worry about setting anything in the member intialiser list."
            ]
          }
        ]
      },
      {
        "title": "class implementation qualified names",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Class-Name Qualification"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "In C++ when you implement a class in a `.cpp` file you must qualify the class name."
            ]
          },
          {
            "type": "Code",
            "language": "cpp",
            "code": [
              "",
              "// in .h",
              "struct X {",
              "  void f(T);",
              "};",
              "",
              "// in .cpp",
              "void X::f(T t = count) { }"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Taken from [here](https://timsong-cpp.github.io/cppwp/n4659/class.mem#class.mfct-4)."
            ]
          }
        ]
      },
      {
        "title": "binary search last",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "The `upper_bound` and `lower_bound` functions give iterators to the first element matching a condition.  ",
              "It is possible to change the behaviour so that the last position is instead returned.",
              "Use reverse iterators in conjunction with the `greater<N>` comparator to do this."
            ]
          },
          {
            "type": "Code",
            "language": "cpp",
            "code": [
              "#include <algorithm>",
              "#include <cassert>",
              "#include <utility>",
              "#include <vector>",
              "",
              "auto main(void) -> int {",
              "    /**",
              "        what is the biggest index from [2, 6) st.",
              "        boxes[i] <= 6",
              "        it is 2, boxes[2] = 5",
              "     */",
              "    auto boxes = std::vector<int>{1 , 3 , 5 , 10, 14, 18};",
              "    //                            0   1   2   3   4   5",
              "    // reverse                 e                      b",
              "    //                         -- ->                  <- ++",
              "    //                            18, 14, 10, 5 , 3 , 1",
              "    //                            0   1   2   3   4   5",
              "    //                                        ^ should be this index",
              "    auto j = std::lower_bound(boxes.rbegin(), boxes.rend() - 1 - 1, 6, std::greater<int>()) - boxes.rbegin();",
              "    assert(j == 3);",
              "}"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              ""
            ]
          }
        ]
      },
      {
        "title": "reverse iterator indexing",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "To access the position of a reverse iterator, you still subtract it from `rbegin`."
            ]
          },
          {
            "type": "Code",
            "language": "cpp",
            "code": [
              "#include <algorithm>",
              "#include <cassert>",
              "#include <iostream>",
              "",
              "int main() {",
              "    auto vec = std::vector<int>{1 , 3 , 5 , 10, 14, 18};",
              "    //                                          j",
              "    // reverse indices",
              "    //                          5   4   3   2   1   0",
              "    auto j = ++vec.rbegin();",
              "    assert(*j == 14);",
              "    auto j_idx = j - vec.rbegin();",
              "    assert (j_idx == 1);",
              "}"
            ]
          }
        ]
      },
      {
        "title": "binary search last exclusive",
        "html": [
          {
            "type": "Paragraph",
            "lines": [
              "The end iterator range is not inclusive for `upper_bound` and `lower_bound`.  "
            ]
          },
          {
            "type": "Code",
            "language": "cpp",
            "code": [
              "#include <algorithm>",
              "#include <cassert>",
              "#include <vector>",
              "",
              "/**",
              "    here 30 > 25",
              "    but the iterator range is end-exclusive so the 30 is not included in the range",
              "*/",
              "auto main(void) -> int {",
              "    auto nums = std::vector<int>{10, 20, 30};",
              "    //                           ^       ^",
              "    //                           b       e - 1",
              "    auto idx = std::upper_bound(nums.begin(), nums.end() - 1, 25);",
              "    assert(idx == nums.end() - 1);",
              "}"
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              ""
            ]
          }
        ]
      },
      {
        "title": "constructor no return type",
        "html": [
          {
            "type": "Header",
            "level": 1,
            "content": "Overview"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Constructors have no return type, so how can you prematurely end one if you need to?"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Error"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "This error will be shown if you try return something inside a constructor."
            ]
          },
          {
            "type": "Paragraph",
            "lines": [
              "> error: constructor ... should not return a value [-Wreturn-type]"
            ]
          },
          {
            "type": "Header",
            "level": 1,
            "content": "Solution"
          },
          {
            "type": "Paragraph",
            "lines": [
              "",
              "Constructors should throw an exception if they fail.",
              "Although essentially a constructor is considered to have a return type of `void`."
            ]
          }
        ]
      }
    ]
  }
]